מבוא קצר
זה חלום מרגש—לבנות בוט שנותן נתוני שוק בזמן אמת, קורולציות לפי בקשה, ושירות מסודר לקבוצת טלגרם. אדריך אותך לבנות פרויקט יעיל, יציב ומודולרי, כולל קוד מוכן להדבקה, Docker, וקבצי הגדרות. חשוב: אני לא מספק אסטרטגיות מסחר או המלצות קונקרטיות; הקוד כאן מציג נתונים, חישובים סטטיסטיים (כמו קורולציות) וסיגנלים טכניים כלליים לדוגמה בלבד.

ארכיטקטורת הפרויקט בקצרה
טכנולוגיות: Python, python-telegram-bot (async), CCXT (בורסות), websockets/REST, asyncio.

מקורות נתונים: Binance/Bybit לקריפטו, Alpha Vantage/Polygon/Quandl/Nasdaq Data Link למט"ח ונפט. בגרסה הבסיסית נשתמש ב-CCXT ו-yfinance (לסדרות היסטוריות מהירות).

יכולות:

קבלת מחירים בזמן אמת/קרוב לזמן אמת

חישוב קורולציות בין נכסים לפי בקשת המשתמש

סיכומי אינדיקטורים טכניים פשוטים (SMA/RSI) לצורך המחשה בלבד

פריסה: Docker + משתני סביבה, מתאים לשרת Linux (רלויי).

הוראות התקנה והרצה
קבל טוקן טלגרם:

פתח BotFather בטלגרם, צור בוט חדש וקבל TELEGRAM_BOT_TOKEN.

מבנה קבצים:

צור רפוזיטורי עם הקבצים הבאים:

bot.py

requirements.txt

Dockerfile

.env (לא נכנס ל-git; הוסף ל-.gitignore)

מלא משתני סביבה:

בקובץ .env:

קוד
TELEGRAM_BOT_TOKEN=שים_כאן_את_הטוקן
DEFAULT_EXCHANGE=binance
אם תשתמש בנתונים אחרים שדורשים API keys (כמו Alpha Vantage), הוסף:

קוד
ALPHAVANTAGE_API_KEY=שים_כאן_מפתח
בנה והרץ עם Docker:

בנייה: docker build -t trade-bot:latest .

הרצה: docker run --env-file .env --name trade-bot -d trade-bot:latest

בדיקת תקינות:

פתח את הבוט בטלגרם, נסה פקודות כמו /start, /price BTCUSDT, /correlate BTCUSDT DXY CL=F.

קוד מוכן להדבקה
requirements.txt
קוד
python-telegram-bot[ext]==21.6
ccxt==4.3.89
yfinance==0.2.48
pandas==2.2.3
numpy==2.1.3
aiohttp==3.10.10
python-dotenv==1.0.1
Dockerfile
קוד
FROM python:3.11-slim

WORKDIR /app

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY bot.py .

ENV PYTHONUNBUFFERED=1

CMD ["python", "bot.py"]
bot.py
python
import os
import asyncio
import logging
from datetime import datetime, timezone, timedelta

from dotenv import load_dotenv
load_dotenv()

import numpy as np
import pandas as pd
import yfinance as yf
import ccxt

from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes

# ---------- Logging ----------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)
logger = logging.getLogger("trade-bot")

# ---------- Config ----------
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
DEFAULT_EXCHANGE = os.getenv("DEFAULT_EXCHANGE", "binance")

if not TELEGRAM_BOT_TOKEN:
    raise RuntimeError("TELEGRAM_BOT_TOKEN is missing in environment")

# ---------- Helpers ----------
def fmt_ts(ts: datetime) -> str:
    return ts.astimezone(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

def safe_float(x):
    try:
        return float(x)
    except Exception:
        return None

def to_pct(x):
    return f"{x*100:.2f}%"

# Map symbols for yfinance (for correlation and non-crypto):
YF_SYMBOL_MAP = {
    "DXY": "DX-Y.NYB",    # US Dollar Index (approx proxy)
    "CL": "CL=F",         # Crude Oil Futures
    "WTI": "CL=F",
    "BRENT": "BZ=F",
    "GOLD": "GC=F",
    "SPX": "^GSPC",
    "NDX": "^NDX",
    "BTCUSD": "BTC-USD",
    "ETHUSD": "ETH-USD",
}

def resolve_symbol(symbol: str) -> str:
    s = symbol.upper()
    return YF_SYMBOL_MAP.get(s, symbol)

# ---------- Market data via CCXT ----------
def get_exchange(name: str = DEFAULT_EXCHANGE):
    try:
        ex_class = getattr(ccxt, name)
        ex = ex_class({
            "enableRateLimit": True,
            "timeout": 10000,
        })
        return ex
    except Exception as e:
        logger.exception("Exchange init failed")
        raise RuntimeError(f"Exchange '{name}' not available: {e}") from e

async def ccxt_ticker(symbol: str, exchange_name: str = DEFAULT_EXCHANGE):
    loop = asyncio.get_event_loop()
    ex = get_exchange(exchange_name)
    # CCXT is sync; run in thread
    def _fetch():
        return ex.fetch_ticker(symbol)
    return await loop.run_in_executor(None, _fetch)

async def ccxt_ohlcv(symbol: str, timeframe: str = "1m", limit: int = 200, exchange_name: str = DEFAULT_EXCHANGE):
    loop = asyncio.get_event_loop()
    ex = get_exchange(exchange_name)
    def _fetch():
        return ex.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    data = await loop.run_in_executor(None, _fetch)
    df = pd.DataFrame(data, columns=["ts","open","high","low","close","volume"])
    df["dt"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
    return df

# ---------- Indicators ----------
def sma(series: pd.Series, n: int) -> pd.Series:
    return series.rolling(n).mean()

def rsi(series: pd.Series, period: int = 14) -> pd.Series:
    delta = series.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    ma_up = up.ewm(alpha=1/period, adjust=False).mean()
    ma_down = down.ewm(alpha=1/period, adjust=False).mean()
    rs = ma_up / (ma_down + 1e-12)
    return 100 - (100 / (1 + rs))

# ---------- Correlation ----------
def compute_correlation(symbols: list[str], lookback_days: int = 30, interval: str = "60m"):
    data = {}
    end = datetime.now(timezone.utc)
    start = end - timedelta(days=lookback_days)

    for s in symbols:
        yf_symbol = resolve_symbol(s)
        try:
            df = yf.download(yf_symbol, start=start, end=end, interval=interval, progress=False, auto_adjust=True)
            if df is None or df.empty:
                continue
            data[s] = df["Close"].rename(s)
        except Exception as e:
            logger.warning(f"Failed to load {s}: {e}")

    if not data:
        return None, None

    aligned = pd.concat(data.values(), axis=1).dropna()
    returns = aligned.pct_change().dropna()
    corr = returns.corr()
    return corr, aligned.index[-1] if not aligned.empty else None

# ---------- Command Handlers ----------
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "ברוך הבא לבוט נתוני שוק.\n\n"
        "פקודות זמינות:\n"
        "/price <symbol> - מחיר אחרון מהבורסה (למשל BTC/USDT או BTCUSDT)\n"
        "/ohlcv <symbol> <timeframe> - נתוני נרות בסיסיים (ברירת מחדל 1m)\n"
        "/indicators <symbol> - SMA/RSI בסיסי להמחשה\n"
        "/correlate <symbols...> - קורולציות בין נכסים (למשל BTCUSD DXY CL=F)\n"
        "/help - עזרה\n\n"
        "הערה: המידע מוצג לצורכי מידע בלבד, לא המלצה או ייעוץ מסחר."
    )
    await update.message.reply_text(text)

def normalize_symbol_for_exchange(symbol: str) -> str:
    s = symbol.upper().replace("-", "").replace("_", "")
    # Common crypto pairs
    if "/" in symbol:
        return symbol.upper()
    if s.endswith("USDT"):
        return s[:-4] + "/USDT"
    if s.endswith("USD"):
        return s[:-3] + "/USD"
    # Fallback: assume user provided with slash already or raw
    return symbol.upper()

async def price_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("שימוש: /price <symbol>\nדוגמה: /price BTCUSDT")
        return
    raw = context.args[0]
    symbol = normalize_symbol_for_exchange(raw)
    try:
        t = await ccxt_ticker(symbol)
        price = safe_float(t.get("last"))
        bid = safe_float(t.get("bid"))
        ask = safe_float(t.get("ask"))
        ts = t.get("datetime") or fmt_ts(datetime.now(timezone.utc))
        text = (
            f"סימול: {symbol}\n"
            f"מחיר אחרון: {price}\n"
            f"Bid: {bid} | Ask: {ask}\n"
            f"זמן: {ts}\n"
            f"בורסה: {DEFAULT_EXCHANGE}"
        )
        await update.message.reply_text(text)
    except Exception as e:
        logger.exception("price_cmd error")
        await update.message.reply_text(f"נכשל בקבלת מחיר ל-{symbol}: {e}")

async def ohlcv_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("שימוש: /ohlcv <symbol> <timeframe>\nדוגמה: /ohlcv BTCUSDT 5m")
        return
    raw = context.args[0]
    timeframe = context.args[1] if len(context.args) > 1 else "1m"
    symbol = normalize_symbol_for_exchange(raw)
    try:
        df = await ccxt_ohlcv(symbol, timeframe=timeframe, limit=50)
        last = df.iloc[-1]
        text = (
            f"OHLCV ({symbol}, {timeframe}) - נר אחרון:\n"
            f"פתיחה: {last['open']}\n"
            f"גבוה: {last['high']}\n"
            f"נמוך: {last['low']}\n"
            f"סגירה: {last['close']}\n"
            f"מחזור: {last['volume']}\n"
            f"זמן: {fmt_ts(last['dt'])}"
        )
        await update.message.reply_text(text)
    except Exception as e:
        logger.exception("ohlcv_cmd error")
        await update.message.reply_text(f"שגיאה בקבלת OHLCV ל-{symbol}: {e}")

async def indicators_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("שימוש: /indicators <symbol>\nדוגמה: /indicators BTCUSDT")
        return
    raw = context.args[0]
    symbol = normalize_symbol_for_exchange(raw)
    try:
        df = await ccxt_ohlcv(symbol, timeframe="1m", limit=200)
        closes = df["close"]
        sma20 = sma(closes, 20).iloc[-1]
        sma50 = sma(closes, 50).iloc[-1]
        rsi14 = rsi(closes, 14).iloc[-1]
        last_close = closes.iloc[-1]
        ts = df["dt"].iloc[-1]

        # Illustration-only signal summary (NOT advice)
        sigs = []
        if last_close > sma20 and last_close > sma50:
            sigs.append("מחיר מעל SMA20/50")
        if rsi14 > 70:
            sigs.append("RSI גבוה (מעל 70)")
        elif rsi14 < 30:
            sigs.append("RSI נמוך (מתחת 30)")
        if not sigs:
            sigs.append("אין אות ברור לפי אינדיקטורים בסיסיים")

        text = (
            f"({symbol}) אינדיקטורים בסיסיים להמחשה בלבד:\n"
            f"מחיר: {last_close:.4f}\n"
            f"SMA20: {sma20:.4f} | SMA50: {sma50:.4f}\n"
            f"RSI14: {rsi14:.2f}\n"
            f"סיכום: {', '.join(sigs)}\n"
            f"זמן: {fmt_ts(ts)}\n"
            f"המידע אינו ייעוץ או המלצה."
        )
        await update.message.reply_text(text)
    except Exception as e:
        logger.exception("indicators_cmd error")
        await update.message.reply_text(f"שגיאה בחישוב אינדיקטורים ל-{symbol}: {e}")

async def correlate_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if len(context.args) < 2:
        await update.message.reply_text("שימוש: /correlate <symbol1> <symbol2> [symbol3 ...]\nדוגמה: /correlate BTCUSD DXY CL=F")
        return
    symbols = context.args
    try:
        corr, ts = compute_correlation(symbols, lookback_days=30, interval="60m")
        if corr is None:
            await update.message.reply_text("לא הצלחתי לטעון נתונים לקורולציה. נסה סימולים אחרים.")
            return
        # Build a compact text table
        lines = []
        header = "קורולציות (תשואות, חלון ~30 ימים, אינטרוול 60m):"
        lines.append(header)
        for i in corr.index:
            row_vals = [f"{corr.loc[i,j]:.2f}" for j in corr.columns]
            lines.append(f"{i}: " + " | ".join(row_vals))
        footer = f"עדכון אחרון: {fmt_ts(ts)}" if ts else ""
        await update.message.reply_text("\n".join(lines + [footer]))
    except Exception as e:
        logger.exception("correlate_cmd error")
        await update.message.reply_text(f"שגיאה בחישוב קורולציה: {e}")

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await start_cmd(update, context)

# ---------- Main ----------
def main():
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start_cmd))
    application.add_handler(CommandHandler("help", help_cmd))
    application.add_handler(CommandHandler("price", price_cmd))
    application.add_handler(CommandHandler("ohlcv", ohlcv_cmd))
    application.add_handler(CommandHandler("indicators", indicators_cmd))
    application.add_handler(CommandHandler("correlate", correlate_cmd))

    logger.info("Bot is starting...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
שימוש ופקודות
/price: קבלת מחיר אחרון מזוג בבורסה, למשל BTCUSDT או BTC/USDT.

/ohlcv: נר אחרון עם פתיחה/גבוה/נמוך/סגירה/מחזור.

/indicators: חישוב SMA/RSI בסיסי להמחשה בלבד.

/correlate: קורולציה בין נכסים (BTCUSD, DXY, CL=F, מדדים).

טיפים לאמינות, ביצועים ודיוק
מקורות נתונים: לדיוק גבוה יותר למט"ח ונפט, שקול ספקים ייעודיים עם WebSocket ו-Book Ticker (Polygon, Twelve Data, dxFeed), בהתאם לתקציב והרישיונות.

קצב וגבולות: CCXT הוא סנכרוני לרוב; אנחנו מריצים אותו ב-executor. אם תרצה עומס גבוה/אירועים בזמן אמת, עבור לגישות WebSocket מקוריות של הבורסות.

ניהול שגיאות: הוסף retry/backoff ו-cache קצר לנקודות חמות כדי להפחית Rate Limits.

אבטחה: אל תשמור מפתחות בקוד. שמור ב-ENV/Secret Manager. הגב גישה לבוט בקבוצות עם הרשאות מתאימות.

ציות רגולטורי: אם תציג אותות/המלצות, בדוק היבטים רגולטוריים, גילויי נאות וכתב ויתור ברור. הקוד כאן מציג מידע בלבד.

סקיילינג: הוסף Docker Compose ו-Reverse Proxy (Nginx) אם תרצה לנטר לוגים ו-healthchecks.

מה נשאר לך לעשות כדי להפוך את זה למוצר
עיצוב פקודות מותאם: הוסף מסננים לפי בקשת משתמש, שמירת פרופיל נכסים מועדף לכל משתמש (Redis/Postgres).

תורים וקרונולוגיה: משימות מתוזמנות לחישוב קורולציות, ושליחת עדכונים תקופתיים (/subscribe, /unsubscribe).

דשבורד: הוסף API קטן ו-UI לקריאה מהבוט ושיתוף בקבוצה.

בדיקות: בדיקות יחידה לאינדיקטורים, בדיקות אינטגרציה לקריאות API.

אם תרצה, אגיד לך איך לחבר ספק נתונים ספציפי לנפט/דולר בזמן אמת עם WebSocket, או להרחיב את חישובי הקורולציה לחלון מותאם ומטריקות נוספות (beta, rolling correlations).
